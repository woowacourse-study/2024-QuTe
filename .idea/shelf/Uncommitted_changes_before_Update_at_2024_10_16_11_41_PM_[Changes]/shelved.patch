Index: zeze/week02_Session&JWT.md
===================================================================
diff --git a/zeze/week02_Session&JWT.md b/zeze/week02_Session&JWT.md
deleted file mode 100644
--- a/zeze/week02_Session&JWT.md	(revision f036eefe59fe6c1f27bfa080d975d3c7685adbb3)
+++ /dev/null	(revision f036eefe59fe6c1f27bfa080d975d3c7685adbb3)
@@ -1,109 +0,0 @@
-## 세션(Session)
-
-세션은 비밀번호 등 클라이언트의 민감한 정보를 브라우저가 아닌 서버 측에 저장하고 관리한다. 서버의 메모리나 로컬 파일 혹은 데이터베이스에 저장하기도 한다. 쿠키에는 세션 ID와 같은 인증 정보를 담아 클라이언트로 보낸다.
-
-![alt text](image.png)
-
-- 클라이언트가 ID/PWD로 서버에 로그인을 요청한다.
-- 사용자를 식별할 수 있는 세션 ID를 만들어 세션 저장소에 저장한다.
-- 쿠키에 세션 ID를 담아 클라이언트에 전송한다.
-- 이후 사용자 인증이 필요한 정보를 요청할 때마다 클라이언트는 세션 ID를 쿠키에 담아 서버에 전달한다.
-
-### 세션 방식의 장/단점
-
-- 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 값을 가지고 있지 않다.
-- 비정상적인 신고가 들어오면 서버에서 세션을 삭제시켜 로그아웃시킬 수 있다.
-- 서비스의 규모가 커져서 서버를 확장한다면 서버마다 세션이 일치하지 않는 문제점이 있다.
-    - 세션 클러스터링(Session Clustering), 스티키 세션(Sticky Session) 방식을 고려해봐야 한다.
-
-### 세션 방식의 활용
-
-- 사용자의 디바이스별로 인증을 관리할 수 있다.
-    - 인프런 강의에서 볼 수 있듯 PC로 접속 시 다른 기기의 접근을 막을 수 있다.
-- 하나의 계정 공유를 관리할 수 있다.
-    - 넷플릭스처럼 계정 공유의 수도 제한할 수 있다.
-
-## JWT(Json Web Token)
-
-JWT는 JSON 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰이다.
-
-![alt text](image-1.png)
-
-- 클라이언트가 ID/PWD로 서버에 로그인을 요청한다.
-- 유효한 ID/PWD라면 Access Token, Refresh Token을 발급하여 쿠키에 담아 전송한다.
-- 이후 사용자 인증이 필요한 정보를 요청할 때마다 클라이언트는 토큰을 쿠키에 담아 서버에 전달한다.
-    - 인증 정보를 전달하는 방법은 여러가지이지만 여기서는 쿠키에 담는 방법으로 설명한다.
-- 토큰이 유효한지 확인하고 유효하다면 응답한다.
-
-### JWT 구성
-
-Header, Payload, Signature 3가지로 구성되어 있다.
-
-**☑️ Header**
-
-JWT 토큰 타입과 Signature에서 사용하는 알고리즘이 포함되어 있다. 대표적으로 RS256(비대칭키)와 HS256(대칭키)가 있다.
-
-**☑️ Payload**
-
-사용자 정보의 한 조각인 클레임(claim)이 들어있다.
-
-- sub : 토큰 제목(subject)
-- aud : 토큰 대상자(audience)
-- iat : 토큰이 발급된 시각 (issued at)
-- exp : 토큰의 만료 시각 (expired)
-
-**☑️ Signature**
-
-헤더와 페이로드의 문자열을 합친 후에, 헤더에서 선언한 알고리즘과 key를 이용해 암호한 값이다. Header와 Payload는 단순히 Base64url로 인코딩되어 있어 누구나 쉽게 복호화할 수 있지만, Signature는 key가 없으면 복호화할 수 없다. 이를 통해 보안상 안전하다는 특성을 가질 수 있다.
-
-### SHA 알고리즘
-
-HS256, RS256 알고리즘에서 공통적으로 쓰이는 단어인 S256 이라는 단어는 SHA256 알고리즘을 의미한다. SHA(Secure Hash Algorithm) 알고리즘의 한 종류로서 256비트로 구성되며 64자리 문자열을 반환한다. 이름에 내포되어 있듯 2^256만큼의 경우의 수를 만들 수 있다. 개인용 컴퓨터로 무차별 대입을 수행해 해시 충돌 사례를 찾으려고 할 때 많은 시간이 소요될 정도로 큰 숫자이므로 충돌로부터 비교적 안전하다고 평가된다.
-
-아래의 두 알고리즘은 해시 알고리즘에 속하기 때문에 복호화 불가능하다는 단방향 특성을 가진다. 또한 원문에 해시 알고리즘을 적용해서 얻은 해시값을 비교해 유효성을 검증한다.
-
-**☑️ HS256 알고리즘**
-
-- 대칭키 암호화 방식이며 Private Key를 알고있는 서버만 Signature 유효성 검증이 가능하다.
-
-**☑️ R256 알고리즘**
-
-- 비대칭키 암호화 방식이며 서버는 Public Key를 사용해 유효성 검증을 한다.
-
-### JWT의 목적은 위조방지
-
-JWT는 Base64로 암호화하기 때문에 쉽게 복호화할 수 있다. 복호화하면 사용자의 데이터를 담은 Payload 부분이 그대로 노출되기 때문에 민감한 정보를 넣지는 말아야 한다. 토큰의 목적은 정보 보호가 아닌 위조 방지이다. Signature의 Secret Key가 노출되지 않는 이상 데이터를 위조해도 유효성 검증에 실패한다.
-
-### JWT 방식의 장/단점
-
-- 인증에 필요한 정보가 토큰에 있기에 별도의 저장소가 필요없다. 따라서 확장성에 용이하다.
-- 토큰에 정보가 많아져 토큰의 크기가 커지면 네트워크에 부하를 줄 수 있다.
-- 중간에 토큰을 탈취하면 Payload의 데이터를 모두 볼 수 있다.
-
-## ✅ 인증/인가 방식 선택 : 세션 VS 토큰
-
-**확장성** 측면에서 세션은 세션 클러스터링, 스티키 세션 등 추가적인 작업이 필요하다. 하지만 토큰은 서버가 직접 인증방식을 저장하지 않고 클라이언트가 저장하는 방식을 취하기 때문에 세션 불일치 문제로부터 자유롭다. HTTP의 Stateless 특성을 그대로 활용할 수 있으며 확장성이 높은 방식이다. **보안성** 측면에서 생각해 볼 때 세션의 경우 모든 정보를 서버에서 관리하기 때문에 토큰에 비해 훨씬 안전하다. 그에 비해 토큰은 한 번 생성하면 서버에서 제어할 수 있는 방법이 없기 때문에 탈취당했을 때 조금 더 복잡한 방식으로 해결할 수 있다. **활용성** 측면에서 생각해보면 세션은 계정 공유 제한, 디바이스별 로그아웃 등 구현 방식에 활용할 수 있다. 프로젝트에서 핵심 기능이 아니라면 이점이 될 수 없지만 말이다.
-
-JWT가 보안상으로 완벽하지는 못하지만 보안을 보완할 수 있는 여러 방법들이 존재한다. 그리고 어느 정도까지는 보안 수준을 높일 수 있다고 생각했다. 또한 구현 방식이 세션에 비해 간단하고 서버 확장시 Stateless한 것이 큰 장점을 될 것이라고 생각해 JWT를 선택했다.
-
-### JWT 전달
-
-JWT를 전달하는 방법은 여러가지가 있는데 어디에 인증정보를 담아야 할까?
-
-**☑️ Authentication Header**
-
-HTTP 표준에서는 Authentication header를 통한 인증을 기본으로 하고 있다. 이 중에서 JWT 기반의 인증 방식의 경우 [**Authentication header + Bearer Token**](https://jwt.io/introduction) 방식을 일반적으로 활용한다.
-
-> Authentication: Bearer
-eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiI2IiwiaWF0IjoxNzI4OTk0MDE3LCJleHAiOjE3Mjg5OTU4MTcsInR5cGUiOiJBQ0NFU1NfVE9LRU4ifQ.r9B3-Obzxhqm5CzFZhiD9y8zQwEvmH2_TBfsrxoxENvS8RCS0fQrn07u5tjM6okFok0OikkZf1fliwrxUtGe3w
-> 
-
-Authentication Header 를 통해서 전송하기 위해서는 Local storage 혹은 Session storage 에서 관리되어야한다. Javascript 코드를 통해 접근이 가능하기에, XSS 공격에 대해서 취약하고 여러 보안 문제가 발생할 수 있어 선택하지 않았다.
-
-**☑️ Request Body**
-
-Request Body에 인증 정보를 싣어 보내는 방법의 경우 **GET, HEAD, DELETE, TRACE** 와 같은 HTTP Method 에서 사용하지 않는다. GET 요청의 경우 RESTful API 설계 원칙에 따르면 안전성과 멱득성을 보장해야 하며 리소스를 가져오는 목적으로만 사용된다. 즉, GET 요청은 서버의 상태를 변경하지 않아야 하고, 여러 번 실행해도 동일한 결과를 반환해야 하기 때문에 바디값을 사용하지 않는다. HEAD, TRACE같은 요청은 바디값을 사용하지 않기 때문에 넣는 것은 의미가 없다. 따라서 Request Body를 사용하는 것이 안티패턴으로 여겨져 사용하지 않는다.
-
-**☑️ Cookie**
-
-Cookie header를 통해 필요한 정보를 cookie 에 담아 교환한다. 서버에서는 set-cookie 를 통해서 클라이언트의 브라우저에게 cookie 를 설정하도록 할 수 있으며, 웹 브라우저 기반의 클라이언트는 브라우저에서 자동으로 이를 관리/전송한다. 쿠키를 사용하면 여러 보안 문제를 해결할 수 있다. 쿠키에 담는 방식이 가장 안전하고 좋은 방식으로 생각된다.
\ No newline at end of file
