## 퍼사드 패턴

- 복잡한 서브 클래스들의 공통적인 기능을 정의하는 상위 수준의 인터페이스를 제공하는 패턴
- 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스(API)를 구성하기 위한 구조 패턴

 퍼사드(Facade) 패턴은 **복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 고객에게 제공**한다고 보면된다.

### 목적

- 서브 클래스의 코드에 의존하는 일을 감소해준다.
- 복잡한 소프트웨어를 간단히 사용 할 수 있게 **간단한 인터페이스를 제공**해준다.
	- 클라이언트로 하여금 복잡한 것을 의식하지 않도록 해주는 것
- 서브 시스템(SubSystem)들 간의 **종속성을 줄여줄 수 있으며**, `퍼사드 객체를 사용하는 곳(Client)`에서는 여러 서브 클래스들을 호출할 필요 없이 편리하게 사용할 수 있다.

### 장점

- `낮은 결합도`  
    Client가 서브 시스템(SubSystem)들의 코드를 몰라도 된다. Facade Object만 알면 사용이 가능하다. 또한 서브 시스템들간의 복잡한 결합도 역시 낮출 수 있다.
    
- `가독성 상승`  
    기존에는 Client에서 여러 서브 클래스들을 직접 호출해야 했다.  
    하지만 Facade Pattern을 사용하면 하나의 객체만을 호출하여 사용할 수 있고, 그 객체의 네이밍 역시 간단명료할 수밖에 없다.
    
- `서브 시스템 직접 접근 가능`  
    필요에 따라 서브 클래스를 직접 사용할 수도 있다. 선택지가 많아진다.

## 재귀적 퍼사드 - Additional Facade

퍼사드 클래스는 반드시 한개만 존재해야 한다는 규칙같은 건 없다. 연관 되지 않은 기능이 있다면 얼마든지 퍼사드 2세로 분리한다. 이 퍼사드 2세는 다른 퍼사드에서 사용할 수도 있고 클라이언트에서 직접 접근할 수도 있다.

다수의 클래스, 다수의 패키지를 포함하고 있는 큰 시스템에 요소 요소 마다 Facade 패턴을 여기 저기 적용하고 다시 그 Facade를 합친 Facade를 만드는 식으로, 퍼사드를 재귀적으로 구성하면 시스템은 보다 편리하게 된다. 이처럼 퍼사드는 한개만 있으라는 법은 없으며 필요에 의하면 얼마든지 늘려 의존할 수 있다.


## 코드잽 서비스에서 퍼사드 패턴 도입 과정

### 전제

템플릿 생성 시 규칙이 복잡하고, 다양한 테이블에 접근해야한다.

1. 카테고리 존재 여부 확인 
   - 없으면 생성
2. 템플릿 생성
3. 소스 코드 생성
4. 템플릿의 대표 소스 코드인 썸네일 생성
5. 템플릿 태그 생성
  - 해당 태그가 없으면 태그 생성

![](https://i.imgur.com/hNpRotM.png)


총 [카테고리, 템플릿, 소스코드, 썸네일, 태그, 태그 템플릿] 6개의 테이블에 변경 사항이 생긴다.
초기에 이를 TemplateService에서 모든 테이블에 Repository에 직접 접근하는 방식으로 구형하였다.
이를 통해 템플릿 생성 메서드의 길이가 너무 컸으면 템플릿 생성 메서드는 단일 책임 원칙을 벗어나 많은 책임을 가지고 있다고 판단했다.

### 도입

이 문제를 해결하고자 퍼사드 패턴을 도입하였고 다음과 같이 수정되었습니다.

![](https://i.imgur.com/T7lXPdi.png)

최상위 `template application service` 를 퍼사드 패턴으로 둔 후 그 내부에 구체적인 구현은 각 도메인의 비즈니스 로직을 담당하는 `serivce` 계층에서 실행되도록 변경하였습니다.

이 외에도 템플릿 수정, 삭제 등 여러 도메인이 연결된 로직은 퍼사드 패턴을 도입하여 개선하였습니다.
