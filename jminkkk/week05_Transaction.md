# Transaction
## ACID

A (atomic): 하나의 트랜잭션은 더이상 쪼개질 수 최소 단위, 즉 원자이다.

같은 트랜잭션 내에 롤백이 발생할 경우 전체가 롤백되어야 한다. 일부만 성공할 수는 없다.

C (consistency): 트랜잭션이 실행되기 전과 후에 모두 데이터베이스의 규약을 만족해야한다.

예를 들어, 회원 테이블에 몸무게 컬럼이 있고 해당 컬럼은 양수여야 한다는 규약이 있는 경우 트랜잭션 실행이 끝난 후에도 이를 만족해야 한다. 어기게 된다면 롤백을 해야한다.

I (isolation): 각 트랜잭션은 독립적이어야 한다. 한 트랜잭션이 진행되는 과정에서 다른 트랜잭션에 영향을 받으면 안된다.

각각을 순차적으로 실행할 때와 동시에 실행할 때 결과가 동일해야 한다.

D (duration): 트랜잭션은 지속되어야 한다. 커밋된 트랜잭션의 결과는 영구적으로 저장되어야 한다.

---

# 격리 수준

## Read Uncommited

한 트랜잭션이 특정 테이블에 대해 쿼리를 실행 중일 때, 커밋되지 않더라도 다른 트랜잭션이 조회할 수 있는 것으로 가장 낮은 격리 수준.

### 문제점: Dirty Read

하나의 트랜잭션에서 데이터를 insert하고 다른 트랜잭션에서 그 데이터를 조회했을 경우 insert한 트랜잭션이 롤백되면 데이터는 사라진다.

하지만 조회해 간 트랜잭션은 모르기 때문에 정합성에 문제가 발생할 수 있다.

## Read Commited

하나의 트랜잭션이 데이터를 변경해도 커밋되지 않으면 다른 트랜잭션을 변경 전의 데이터를 보게 된다.

이때 변경이 발생할 때 언두로그에 변경 전 데이터를 복사해두고 다른 트랜잭션이 조회할 때는 언두로그의 데이터를 반환하게 한다.

### 문제점: Non Repeatable Read

Read Uncommited와 비슷하게 한 트랜잭션이 커밋이 도중에 완료된다면 다른 트랜잭션은 커밋된 데이터를 조회할 수 있다. 이때 커밋되기 전의 데이터와 값이 다르기 때문에 동일한 쿼리로 조회해도 다른 결과를 반환하게 된다.

## REPEATABLE_READ

MySQL 기본 격리 수준

하나의 트랜잭션 안에서는 항상 동일한 결과값을 반환하는 것

mysql에서 모든 트랜잭션은 고유한 아이디 값을 가지는데, 이때 테이블에 트랜잭션 아이디를 함께 저장한다. 만약 조회 시 현재 트랜잭션보다 아이디값이 이후이면 언두로그에 백업된 데이터를 조회한다.

### 문제점: Phantom Read

Select for update 발생 시 x락을 걸어야 하는데 언두로그에는 락을 걸 수 없다. 따라서 현재 레코드의 값을 가져오는데 이때 언두로그의 값이 아니기 때문에 다른 값이 조회될 수 있다.

## Serializable

가장 엄격한 격리 수준으로 동시 처리 성능이 떨어진다.

InnoDB에서는 기본적으로 순수한 select 작업은 아무런 레코드 잠금도 설정하지 않고 실행하는데 격리 수준이 serializable인 경우 읽기 작업도 s락을 획득해야 한다.
