# MySQL 실행계획

## MySQL 실행 계획이란?

옵티마이저가 해당 쿼리를 어떻게 실행할 것인지에 대한 정보를 말한다.

Explain 키워드를 통해 실행 계획을 확인할 수 있다.

## 실행 계획 내용

### Id 컬럼
단위 select 쿼리별로 부여되는 식별자 값
- 조인을 할 경우, 실행되는 레코드가 조인되는 테이블의 갯수만큼 추가되지만 id값은 같은 id로 부여
- 쉽게 말해서, select 하나당 id 값 하나가 부여
- 단, id의 값이 테이블의 접근 순서는 아니다. id가 1이라고 해서 해당 select를 먼저 조회하지는 않음

## select_type
SELECT 쿼리가 어떤 타입의 쿼리인지 출력

- 주요 타입
  - simple: 서브쿼리나 union이 없는 단순한 쿼리
  - primary: 서브쿼리나 union를 가지는 쿼리 중에서 가장 바깥쪽에 있는 쿼리
  - union: union으로 결합하는 쿼리 중 첫 번째를 제외한 쿼리들
  - subquery: from 절을 제외한! 곳에서 사용되는 서브 쿼리

### table

사용하는 테이블

> 테이블이 참조되지 않은 경우 null

### type

MySQL 서버가 레코드를 어떤 방식으로 읽었는지(인덱스 or 풀 테이블 등)

- system
  - 레코드가 1건만 존재하거나 아예 없는 테이블인 경우
  - InnoDB에서는 나타나지 않음
- const
  -  테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 == 조건절이며 반드시 1건 이상을 반환하는 쿼리
- qe_ref
  - 조인에서 첫 번째 읽은 테이블의 컬럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 == 조건 검색
- ref
  - 조인, 인덱스의 순서에 상관없이 == 조건으로 검색
- fulltext
  - 전문 검색 인덱스를 사용했을 경우
- range
  - 인덱스 레인지 스캠인 경우 
- index_merge
  - 여러개의 인덱스를 사용했을 경우 나타나며 하나의 인덱스 이름만 표시
- index
  - 인덱스 풀 스캔!인 경우
- ALL
- ref_or_null, unique_subquery, index_subquery

### possible_keys

옵티마이저가 최적의 실행 계획을 위해 고려했던 후보 인덱스 목록
- 실제로 사용되지는 않는다. 주의!

### key

최종 선택된 실행 계획에서 사용하는 인덱스
- primary인 경우 pk를 인덱스롤 사용한다는 뜻

### key_len
실제로 사용할 인덱스의 길이

### ref
참조 조건으로 어떤 값이 제공되었는지

### rows

옵티마이저가 쿼리를 처리하기 위해 읽어야 하는 행의 갯수

### filtered

얼마나 데이터가 필터링이 되었는지

### extra

SQL문을 어떻게 수행할것인지에 대한 추가 정보를 보여주는 항목

- Using filesort
  - MySQL이 정렬을 위해 추가적인 정렬 작업 수행
  - 인덱스를 사용하지 않는 정렬
  - 성능상 불리함
- Using temporary
  - 임시 테이블을 사용해서 처리한 경우
  - GROUP BY와 ORDER BY가 다른 경우 자주 발생
- Using index
  - 커버링 인덱스가 적용된 경우
  - 데이터 파일 접근없이 인덱스만으로 처리 가능
- Using index condition
  - 조건 처리를 MySQL 엔진이 아닌 스토리지 엔진 단계에서 미리 하는 인덱스 푸시 다운이 된 경우
  - 불필요한 테이블 접근을 줄임

