# SSL

## SSL이 무엇인가?

**SSL(Secure Sockets Layer)**은 인터넷 상에서 데이터를 안전하게 전송하기 위한 프로토콜

현재 SSL은 TLS(Transport Layer Security)라는 이름으로 알려져 있으며, 이는 SSL의 후속 버전

HTTP와 결합하여 사용되는 경우, HTTPS(Hypertext Transfer Protocol Secure)로 불림

## HTTP와 HTTPS의 차이점

1. **보안성**:
    - **HTTP**: 데이터가 암호화되지 않은 상태로 전송
        
        중간에서 패킷을 가로채거나 수정할 수 있는 공격에 취약
        
    - **HTTPS**: SSL/TLS를 사용하여 데이터가 암호화되어 전송
        
         이로 인해 데이터의 무결성과 기밀성이 보장되며, 중간에서 공격자가 데이터를 읽거나 수정하는 것을 방지합니다.
        
2. **인증**:
    - **HTTP**: 서버의 신원을 확인할 방법이 없기 때문에, 사용자는 악성 서버와 연결될 수 있음
    - **HTTPS**: SSL 인증서를 사용하여 서버의 신원을 검증
        
        사용자는 웹사이트의 인증서를 통해 서버가 신뢰할 수 있는지 확인
        
3. **포트**:
    - **HTTP**: 기본적으로 80번 포트를 사용합니다.
    - **HTTPS**: 기본적으로 443번 포트를 사용합니다.

## SSL/TLS의 작동 방식

### 1. **핸드셰이크 과정**: 클라이언트와 서버 간의 암호화 협상

핸드셰이크는 클라이언트(예: 웹 브라우저)와 서버 간의 안전한 통신 채널을 설정하는 첫 번째 단계

여기서 양측은 **통신에 사용할 보안 프로토콜과 암호화 방식에 대해 협의**

1. **클라이언트 헬로 (Client Hello)**:
    - 클라이언트는 핸드셰이크를 시작하면서 서버에 "헬로" 메시지를 전송
    - 이 메시지에는 클라이언트가 지원하는 **SSL/TLS 버전**(예: TLS 1.2, 1.3),  **암호화 알고리즘 목록**(Cipher Suites), **압축 방식**, **난수**(랜덤 데이터) 등이 포함
2. **서버 헬로 (Server Hello)**:
    - 서버는 클라이언트의 메시지를 수신한 후, 클라이언트가 제시한 옵션 중에서 자신이 지원하는 **TLS 버전**과 **암호화 알고리즘**을 선택하여 응답
    - 서버 역시 **난수**를 클라이언트에게 전송
    - 이렇게 협의된 암호화 방식과 프로토콜을 통해 이후의 통신이 암호화

> 핸드셰이크의 목적은 양측이 지원하는 암호화 방법을 협상하고, 안전한 키 교환을 준비하는 것
> 

---

### 2. **서버 인증**: 서버의 신뢰성 확인

이 단계에서는 서버가 자신의 **SSL 인증서**를 클라이언트에 제공하여 자신의 신원을 증명

1. **서버 인증서 전송**:
    - 서버는 **인증 기관(CA, Certificate Authority)**이 발급한 SSL 인증서를 클라이언트에게 전송
    - 이 인증서에는 서버의 **공개 키**와 **서버의 신원 정보**(서버 도메인, 만료일, 인증 기관 정보 등)가 포함
2. **클라이언트 인증서 검증**:
    - 클라이언트는 서버로부터 받은 인증서를 검토하여 신뢰할 수 있는지 검증
    - 클라이언트는 이 인증서가 **신뢰할 수 있는 인증 기관**에 의해 서명되었는지 확인
    - 또한, 클라이언트는 인증서에 명시된 **서버 도메인**이 자신이 접속하려는 도메인과 일치하는지 확인하여 서버의 신뢰성을 검증

> 서버 인증의 목적은 클라이언트가 신뢰할 수 있는 서버와 통신 중이라는 것을 확인하는 것
> 

---

### 3. **세션 키 생성**: 안전한 대칭 키 교환

이 단계에서는 클라이언트와 서버가 통신에 사용할 **대칭 키(세션 키)**를 생성

이 대칭 키는 이후의 데이터 암호화에 사용

1. **세션 키 생성 방법**:
    - **RSA**: 클라이언트는 서버의 **공개 키**를 사용하여 임시 세션 키를 암호화한 후 서버에 전송
        
        서버는 자신의 **비공개 키**로 이를 복호화하여 세션 키를 얻음
        
    - **Diffie-Hellman 키 교환**: 클라이언트와 서버가 **난수**를 사용해 서로 데이터를 교환하고, 이를 바탕으로 **대칭 키**를 독립적으로 생성
        
        이 방식은 비대칭 암호화를 사용하지 않고, 안전하게 세션 키를 교환할 수 있음
        
2. **세션 키 사용**:
    - 생성된 세션 키는 대칭 키로, 클라이언트와 서버 간의 모든 통신은 이 세션 키를 사용해 암호화
    - 대칭 키 암호화는 속도가 빠르고, 양측이 동일한 키를 사용하여 데이터를 암호화하고 복호화

> 세션 키의 목적은 이후의 데이터 전송을 효율적이고 안전하게 암호화하는 것
> 

---

### 4. **데이터 전송**: 세션 키를 사용한 안전한 통신

핸드셰이크가 완료되고 세션 키가 생성되면, 클라이언트와 서버는 이 세션 키를 사용하여 모든 데이터 전송을 암호화

1. **대칭 암호화**:
    - 클라이언트와 서버는 각각 데이터를 세션 키로 암호화하고, 상대방은 동일한 키로 이를 복호화
    - 대칭 키는 **AES**(Advanced Encryption Standard)와 같은 알고리즘을 통해 데이터의 기밀성과 무결성을 보장
2. **무결성 검사**:
    - SSL/TLS는 데이터를 암호화할 뿐 아니라 **해시 함수**를 사용하여 전송된 데이터의 무결성도 보장
    - 클라이언트와 서버는 데이터를 전송할 때 **메시지 인증 코드(MAC)**를 추가하여, 수신자가 데이터를 받았을 때 이 코드로 데이터가 중간에서 변조되지 않았는지 확인 가능
3. **암호화된 데이터 전송**:
    - 클라이언트와 서버는 세션 키를 사용해 암호화된 형태로 데이터를 주고받으며, 이를 통해 외부에서 중간에 데이터를 가로채더라도 내용을 이해할 수 없게 만듦

> 데이터 전송의 목적은 양측이 주고받는 모든 데이터를 안전하게 암호화하고, 무결성을 보장하는 것
> 

## 내가 느낀 필요성

로그인 요청 시 이메일과 비밀번호 같은 민감한 정보를 전송할 때, body를 별도로 암호화해야 하지 않나 하는 의문이 생김

하지만 **HTTPS**를 사용하면, 이미 **SSL/TLS 프로토콜**을 통해 클라이언트와 서버 간의 모든 데이터가 자동으로 암호화됨

따라서, **HTTPS** 환경에서는 body를 추가로 암호화할 필요가 없음

 HTTPS는 전송되는 요청의 **전체 내용**을 포함해, 헤더와 body를 모두 안전하게 보호하기 때문

## 내가 찾은 문제점

HTTPS는 서버와 클라이언트 간의 통신을 암호화하여 네트워크 구간에서 데이터를 보호

이로 인해 네트워크를 가로채려는 공격자는 암호화된 데이터만 볼 수 있어 보안이 강화됨

그러나 HTTPS는 **네트워크 전송 이전**에 발생하는 취약점에 대해선 보호가 불가능

예를 들어, 사용자가 비밀번호를 입력하고 로그인 버튼을 눌렀을 때, **브라우저의 개발자 도구**에서 해당 비밀번호가 평문(암호화되지 않은 상태)으로 노출될 수 있음

개발자 도구의 네트워크 탭을 보면, HTTP 요청에 포함된 비밀번호가 평문으로 표시되어 있어 **클라이언트 측에서의 보안**이 취약한 상황이 발생할 수 있음

## 이에 관한 의견

네트워크 전송 이전 구간에서 보안을 적용하는 것은 리소스를 많이 소모하는 작업

특히 서버 자원, 사용자 응답 시간, 그리고 보안의 중요성을 모두 고려했을 때, 이러한 구간에 보안을 무조건 적용하는 것이 항상 효율적인 선택은 아님

오히려 **리소스 관리 및 성능 최적화** 측면에서, 꼭 필요한 구간에만 보안을 집중하고, 나머지 구간에는 다른 보안 방법을 조합해 적용하는 것이 실용적
