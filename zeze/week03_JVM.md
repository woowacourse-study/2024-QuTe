## JAVA의 컴파일과 실행

컴퓨터는 우리가 작성한 소스코드를 이해하지 못한다. 컴퓨터가 이해할 수 있는 언어는 기계어이며 0과 1로 이루어져 있다. 그래서 우리가 작성한 소스코드를 컴퓨터가 이해할 수 있는 기계어로 변환해야 한다.

하지만 자바에서는 소스코드가 바로 기계어로 컴파일되지 않는다. 일차적으로 소스코드(`.java`)가 자바 컴파일러인 javac에 의해 JVM에서 해석되는 중간 코드인 바이트 코드(`.class`)가 컴파일된다. 

그 다음 링크 과정을 거친다. 링크란 여러 개로 분리된 소스파일들을 최종 실행 가능한 파일로 만들기 위해 서로 연결해주는 작업이다. 자바 프로그램 실행 도중 JVM이 필요한 클래스를 찾아서 클래스 패스(Class Loader에 의해)에 로드해준다.

그리고 JVM내의 Execution Engine에 의해 바이트 코드가 기계어로 바뀐다. 이때 인터프리터, JIT 컴파일러 두 가지 방식이 있다.

## JVM 이란 무엇인가

JVM은 Java Virtual Machine의 약자로 자바를 실행시키기 위한 가상 머신이다. 머신이라는 말이 어색하지만, 자바 소스코드를 실행시키기 위해 컴퓨터 속에 존재하는 또 다른 컴퓨터 정도로 이해하면 된다. 위에서 보았듯, 우리가 자바로 작성한 소스코드(`.java`)는 Java Byte Code(`.class`) 로 변환되어 JVM 에 의해 해석되고 실행된다.

자바의 가장 큰 장점은 운영체제에 독립적(WORA)이라는 것이다. JVM 덕분에 자바는 어떤 운영체제 위에서도 실행 파일의 변경 없이 동일한 모습으로 실행 가능하다.

C 언어는 운영체제에 따라 다른 목적 파일(기계어)을 생성하지만, 자바는 목적 파일(바이트코드) 를 만들고 실제 물리적인 컴퓨터 내에 자바 언어가 운영체제에 따라 영향을 받지 않도록 JVM 을 이용하여 가상 컴퓨터 환경을 구축하고 그곳에 목적 파일을 던져 자바 코드를 실행시킨다.

자바 코드는 컴퓨터에서 바로 실행한, 완전히 컴파일된 상태가 아니고 실행 시 JVM을 통해 해석되기 때문에 속도가 느리다는 단점이 있다.요즘엔 바이트코드를 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어 속도 문제는 상당히 개선되었다.

## JVM 메모리 구조

### 1. Class Loader

자바 클래스들은 시작시 한번에 로드되지 않고 애플리케이션에서 필요할 때 로드된다. 클래스 로더는 런타임에 클래스를 동적으로 JVM에 로드하는 역할을 수행한다. 자바의 클래스들은 자바 프로세스가 새로 초기화되면 클래스 로더가 차례차례 로딩되며 작동한다.

**Bootstrap Class Loader**

JVM 시작 시 최초로 실행되는 클래스 로더이다. 부트스트랩 클래스 로더는 자바 클래스를 로드하는 것이 아니라 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 자바 클래스(java.lang.Object, Class, ClassLoader)만을 로드한다.

**Extension Class Loader**

확장 클래스 로더는 부트스트랩 클래스 로더를 부모로 갖는 클래스 로더로서, 확장 자바 클래스들을 로드한다. java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일을 로드하고, 이 값이 설정되어 있지 않은 경우 ${JAVA_HOME}/jre/lib/ext 에 있는 클래스 파일을 로드한다.

**System Class Loader**

자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일 혹은 jar에 속한 클래스들을 로드한다. 쉽게 말하자면, 우리가 만든 .class 확장자 파일을 로드한다.

### 2. **Runtime Data Area**

JVM이 프로그램을 실행하기 위해 운영체제로부터 할당받은 메모리 공간이다. 클래스 로더가 배치한 데이터들을 보관하는 저장소로 5가지 구성요소로 나뉘어져 있다. Stack, PC, Native Method Stacks는 스레드마다 하나씩 생성되며 그 외의 메모리 영역은 모든 스레드가 공유한다.

**Method Area**

프로그램 실행 중 클래스나 인터페이스를 사용하게 되면 JVM은 ClassLoader에게 요청하여 클래스와 인터페이스의 메타데이터를 Method Area에 저장한다. 클래스에 대한 정보가 이 영역에 존재하기 때문에 인스턴스를 생성하기 위해서는 Method Area를 참조해야 하며, 따라서 모든 쓰레드가 이 영역을 공유하게 된다.

**Heap Area**

런타임시 동적으로 메모리가 할당되고 소멸되는 영역이며 GC(Garbage Collection)을 수행하는 영역이다. Heap 영역이 가득 차게 되면 OutOfMemoryError가 발생한다.

Heap 영역은 효율적인 GC를 위해 3가지 영역으로 구분된다.

- Young(New) Generation
- Tenured(Old) Generation
- Permanent Generation(Metaspace)

**Stack Area**

지역변수, 매개변수, 리턴값 등 임시적으로 사용되는 값들이 저장되는 영역이다. 프로그램 실행 시 메소드가 실행되면 JVM은 Stack영역에 해당 메소드의 frame을 push하고, 데이터를 임시적으로 저장한다. 메소드가 종료되면 Stack에서 해당 메소드의 frame을 pop한다. 만약 스레드가 사용할 수 있는 스택의 크기를 넘기게 되면 StackOverflowError가 발생한다. 또한 스택을 동적으로 확장할 때 확장할 메모리가 부족하거나 새로운 스레드 생성 시 스택에 할당할 메모리가 부족하면 OutOfMemoryError가 발생한다.

Stack의 기본 자료구조인 Frame은 3가지 요소로 구성된다.

- ConstantPool Reference
- Local Variables Array
- Operand Stack

**PC Register**

현재 스레드가 실행되는 부분의 주소와 명령을 저장하는 영역이다. PC Register에는 멀티 쓰레드 프로그래밍 환경에서 한 쓰레드가 작업을 하다가 다른 쓰레드로 CPU자원을 넘겨주고 다시 받았을 때, 이어서 작업을 하기 위해 현재 실행중인 명령어의 주소를 기록한다.

**Native Method Stack**

자바 이외의 언어가 JVM에서 동작하기 위해 할당한 메모리 영역으로, 일반적으로 C스택을 사용한다. 스레드에서 java메소드가 아닌 Native방식을 사용하는 메소드를 실행하면 이 곳에 해당 메소드에 대한 정보를 저장한다.

### 3. Execution Engine

메모리에 할당된 바이트 코드를 실행하는 역할을 담당한다.